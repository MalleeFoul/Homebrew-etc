diff --git a/gdk/quartz/gdkevents-quartz.c b/gdk/quartz/gdkevents-quartz.c
index f199298..5bd1ab6 100644
--- a/gdk/quartz/gdkevents-quartz.c
+++ b/gdk/quartz/gdkevents-quartz.c
@@ -65,6 +65,18 @@ gdk_quartz_event_get_nsevent (GdkEvent *event)
   return ((GdkEventPrivate *) event)->windowing_data;
 }
 
+/* A category that exposes the protected carbon event for an NSEvent. */
+@interface NSEvent (GdkQuartzNSEvent)
+- (void *)gdk_quartz_event_ref;
+@end 
+
+@implementation NSEvent (GdkQuartzNSEvent)
+- (void *)gdk_quartz_event_ref
+	{
+		return _eventRef;
+	}
+	@end
+
 static void
 gdk_quartz_ns_notification_callback (CFNotificationCenterRef  center,
                                      void                    *observer,
@@ -1306,6 +1318,63 @@ test_resize (NSEvent *event, GdkWindow *toplevel, gint x, gint y)
 }
 
 static gboolean
+	_gdk_quartz_possibly_forward_accelerator (NSEvent* nsevent)
+		{
+			/* Special-case menu shortcut events. We create command events for
+			* those and forward to the corresponding menu.
+			*/
+			if ((!_gdk_quartz_keyboard_grab_window ||
+				(_gdk_quartz_keyboard_grab_window && keyboard_grab_owner_events)) &&
+					[nsevent type] == NSKeyDown)
+						{
+							EventRef event_ref;
+							MenuRef menu_ref;
+							MenuItemIndex index;
+							
+							event_ref = [nsevent gdk_quartz_event_ref];
+							if (IsMenuKeyEvent (NULL, event_ref,
+												kMenuEventQueryOnly,
+												&menu_ref, &index))
+							{
+								MenuCommand menu_command;
+								HICommand hi_command;
+								
+								if (GetMenuItemCommandID (menu_ref, index, &menu_command) != noErr)
+									return FALSE;
+								
+								hi_command.commandID = menu_command;
+								hi_command.menu.menuRef = menu_ref;
+								hi_command.menu.menuItemIndex = index;
+								CreateEvent (NULL, kEventClassCommand, kEventCommandProcess, 
+								0, kEventAttributeUserEvent, &event_ref);
+								SetEventParameter (event_ref, kEventParamDirectObject, 
+								typeHICommand, 
+								sizeof (HICommand), &hi_command);
+								SendEventToEventTarget (event_ref, GetMenuEventTarget (menu_ref));
+								
+								ReleaseEvent (event_ref);
+								
+								return TRUE;
+							}
+						}
+					return FALSE;
+					}
+gboolean
+gdk_quartz_possibly_forward (GdkEvent* event)
+	{
+		NSEvent *nsevent;
+		g_return_val_if_fail (event != NULL, FALSE);
+		
+		nsevent = ((GdkEventPrivate*)event)->windowing_data;
+		
+		if (nsevent)
+			return _gdk_quartz_possibly_forward_accelerator (nsevent);
+		
+		return FALSE;
+	}
+	
+	static gboolean	
+								
 gdk_event_translate (GdkEvent *event,
                      NSEvent  *nsevent)
 {
diff --git a/gtk/gtkdnd-quartz.c b/gtk/gtkdnd-quartz.c
index 62b8570..395c822 100644
--- a/gtk/gtkdnd-quartz.c
+++ b/gtk/gtkdnd-quartz.c
@@ -891,6 +891,8 @@ gtk_drag_dest_drop (GtkWidget	     *widget,
 	gtk_drag_get_data (widget, context, target, time);
     }
   
+  /* leave a note for the source-side context about the action chosen */
+	
   g_signal_emit_by_name (widget, "drag-drop",
 			 context, x, y, time, &retval);
 
@@ -1550,6 +1552,7 @@ gtk_drag_source_unset_icon (GtkDragSourceSite *site)
 
 static void 
 gtk_drag_source_site_destroy (gpointer data)
+	
 {
   GtkDragSourceSite *site = data;
 
diff --git a/gtk/gtkquartz.c b/gtk/gtkquartz.c
index d630abc..a3457a9 100644
--- a/gtk/gtkquartz.c
+++ b/gtk/gtkquartz.c
@@ -24,6 +24,23 @@
 #include <gdk/quartz/gdkquartz.h>
 #include "gtkalias.h"
 
+NSImage *
+_gtk_quartz_create_image_from_drawable (GdkDrawable* drawable)
+{
+		GdkPixbuf* pixbuf;
+		NSImage* image = NULL;
+		
+		pixbuf = gdk_pixbuf_get_from_drawable (NULL, drawable, NULL,
+												0, 0, /* src */
+												0, 0, /* dst */
+												-1, -1);
+			if (pixbuf)
+				image = _gtk_quartz_create_image_from_pixbuf (pixbuf);
+			
+			return image;
+}
+		
+		
 NSImage *
 _gtk_quartz_create_image_from_pixbuf (GdkPixbuf *pixbuf)
 {
diff --git a/gtk/gtkquartz.h b/gtk/gtkquartz.h
index 41fa1ee..784dff0 100644
--- a/gtk/gtkquartz.h
+++ b/gtk/gtkquartz.h
@@ -40,6 +40,7 @@ void _gtk_quartz_set_selection_data_for_pasteboard (NSPasteboard *pasteboard,
 						    GtkSelectionData *selection_data);
 			
 NSImage *_gtk_quartz_create_image_from_pixbuf (GdkPixbuf *pixbuf);
+NSImage *_gtk_quartz_create_image_from_drawable (GdkDrawable *drawable);
 			    
 G_END_DECLS
 
diff --git a/gtk/gtktooltip.c b/gtk/gtktooltip.c
index 9918165..41d52b7 100644
--- a/gtk/gtktooltip.c
+++ b/gtk/gtktooltip.c
@@ -505,6 +505,7 @@ void
 gtk_tooltip_trigger_tooltip_query (GdkDisplay *display)
 {
   gint x, y;
+  gint rx, ry;
   GdkWindow *window;
   GdkEvent event;
 
@@ -512,10 +513,14 @@ gtk_tooltip_trigger_tooltip_query (GdkDisplay *display)
   window = gdk_display_get_window_at_pointer (display, &x, &y);
   if (!window)
     return;
-
+  
+  gdk_window_get_origin (window, &rx, &ry);
+  
   event.type = GDK_MOTION_NOTIFY;
   event.motion.window = window;
   event.motion.x = x;
+  event.motion.x_root = rx + x;
+  event.motion.y_root = ry + y;
   event.motion.y = y;
   event.motion.is_hint = FALSE;
 
diff --git a/gtk/gtktreeview.c b/gtk/gtktreeview.c
index 89301eb..164f3f8 100644
--- a/gtk/gtktreeview.c
+++ b/gtk/gtktreeview.c
@@ -2589,6 +2589,7 @@ gtk_tree_view_button_press (GtkWidget      *widget,
       gboolean row_double_click = FALSE;
       gboolean rtl;
       gboolean node_selected;
+	  gboolean edits_allowed;
 
       /* Empty tree? */
       if (tree_view->priv->tree == NULL)
@@ -2697,10 +2698,18 @@ gtk_tree_view_button_press (GtkWidget      *widget,
 	}
 
       tree_view->priv->focus_column = column;
+	  
+	  /* ARDOUR HACK */
+	  if (g_object_get_data (G_OBJECT(tree_view), "mouse-edits-require-mod1")) {
+		  edits_allowed = (event->state & GDK_MOD1_MASK);
+	  } else {
+			/* regular GTK design: do edits if none of the default modifiers are active */
+			edits_allowed = !(event->state & gtk_accelerator_get_default_mod_mask ());
+		}
+			 		
 
       /* decide if we edit */
-      if (event->type == GDK_BUTTON_PRESS && event->button == 1 &&
-	  !(event->state & gtk_accelerator_get_default_mod_mask ()))
+		if (event->type == GDK_BUTTON_PRESS && event->button == 1 && edits_allowed)
 	{
 	  GtkTreePath *anchor;
 	  GtkTreeIter iter;
